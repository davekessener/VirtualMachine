(defun derive (poly var)
	(let
		(
		 (funmap 
		 	(list
				(cons '+ #'(lambda (a b) (list '+ (derive a var) (derive b var))))
				(cons '- #'(lambda (a b) (list '- (derive a var) (derive b var))))
				(cons '* #'(lambda (a b) (list '+ (list '* a (derive b var)) (list '* (derive a var) b))))
				(cons '/ #'(lambda (a b) (list '/ (derive (list '* a b) var) (list '* b b))))
				(cons '^ #'(lambda (a b) (list '* (derive a var) (list '* b (list '^ a (list '- b 1))))))
				(cons 'sin #'(lambda (a) (list '* (derive a var) (list 'cos a))))
				(cons 'cos #'(lambda (a) (list '* -1 (list '* (derive a var) (list 'sin a)))))
			)
		 )
		)
		(if (atom poly) 
			(if (equal poly var) 1 0)
			(apply (cdr (assoc (car poly) funmap)) (cdr poly))
		)
	)
)

(defun simplify (term)
	(if (atom term)
		term
		(let
			(
			 (op (car term))
			 (ft (simplify (cadr term)))
			 (st (if (null (cddr term)) nil (simplify (caddr term))))
			)
			(cond
				((and (listp ft) (numberp st) (equal op (car ft)))
					(cond
						((numberp (cadr ft)) (simplify (list op (list op st (cadr ft)) (caddr ft))))
						((numberp (caddr ft)) (simplify (list op (list op st (caddr ft)) (cadr ft))))
						(t (simplify (list op ft st)))
					)
				)
				((and (listp st) (numberp ft) (equal op (car st)))
					(cond
						((numberp (cadr st)) (simplify (list op (list op ft (cadr st)) (caddr st))))
						((numberp (caddr st)) (simplify (list op (list op ft (caddr st)) (cadr st))))
						(t (simplify (list op ft st)))
					)
				)
				((equal op '+)
					(cond
						((== ft 0) st)
						((== st 0) ft)
						((and (numberp ft) (numberp st)) (+ ft st))
						((equal ft st) (list '* 2 ft))
						(t (list '+ ft st))
					)
				)
				((equal op '-)
					(cond
						((and (== ft 0) (== st 0)) 0)
						((== ft 0) (list '* -1 st))
						((== st 0) ft)
						((and (numberp ft) (numberp st)) (- ft st))
						(t (list '- ft st))
					)
				)
				((equal op '*)
					(cond
						((or (== ft 0) (== st 0)) 0)
						((== ft 1) st)
						((== st 1) ft)
						((and (numberp ft) (numberp st)) (* ft st))
						((equal ft st) (list '^ ft 2))
						(t (list '* ft st))
					)
				)
				((equal op '/)
					(cond
						((and (listp st) (equal (car st) '/)) (simplify (list '* ft (simplify (list '/ (caddr st) (cadr st))))))
						((== ft 0) 0)
						((== st 1) ft)
						((or (numberp ft) (numberp st)) (/ ft st))
						((equal ft st) 1)
						(t (list '/ ft st))
					)
				)
				((equal op '^)
					(cond
						((== st 0) 1)
						((== st 1) ft)
						(t (list '^ ft st))
					)
				)
				((equal op 'sin)
					(if (numberp ft) (sin ft) (list 'sin ft))
				)
				((equal op 'cos)
					(if (numberp ft) (cos ft) (list 'cos ft))
				)
				(t (error "~&Unknown operator: ~S" op))
			)
		)
	)
)

(defun print-poly (term)
	(if (atom term)
		term
		(if (== 3 (length term))
			(list (print-poly (cadr term)) (car term) (print-poly (caddr term)))
			(list (car term) (list (print-poly (cadr term))))
		)
	)
)

