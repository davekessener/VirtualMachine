(defun derive (poly var)
	(let
		(
		 (funmap 
		 	(list
				(cons '+ #'(lambda (a b) (list '+ (derive a var) (derive b var))))
				(cons '- #'(lambda (a b) (list '- (derive a var) (derive b var))))
				(cons '* #'(lambda (a b) (list '+ (list '* a (derive b var)) (list '* (derive a var) b))))
				(cons '/ #'(lambda (a b) (list '/ (derive (list '* a b) var) (list '* b b))))
				(cons '^ #'(lambda (a b) (list '* (list '^ a b) (list '+ (list '* (derive b var) (list 'ln a)) (list '* b (list '/ (derive a var) a))))))
				(cons 'sin #'(lambda (a) (list '* (derive a var) (list 'cos a))))
				(cons 'cos #'(lambda (a) (list '* -1 (list '* (derive a var) (list 'sin a)))))
				(cons 'ln #'(lambda (a) (list '/ (derive a var) a)))
			)
		 )
		)
		(if (atom poly) 
			(if (equal poly var) 1 0)
			(apply (cdr (assoc (car poly) funmap)) (cdr poly))
		)
	)
)

(defun simplify (term)
	(if (atom term)
		term
		(let
			(
			 (op (car term))
			 (ft (simplify (cadr term)))
			 (st (if (null (cddr term)) nil (simplify (caddr term))))
			)
			(cond
				((and (listp ft) (numberp st) (or (equal op '+) (equal op '*)) (equal op (car ft)))
					(cond
						((numberp (cadr ft)) (simplify (list op (list op st (cadr ft)) (caddr ft))))
						((numberp (caddr ft)) (simplify (list op (list op st (caddr ft)) (cadr ft))))
						(t (simplify (list op ft st)))
					)
				)
				((and (listp st) (numberp ft) (or (equal op '+) (equal op '*)) (equal op (car st)))
					(cond
						((numberp (cadr st)) (simplify (list op (list op ft (cadr st)) (caddr st))))
						((numberp (caddr st)) (simplify (list op (list op ft (caddr st)) (cadr st))))
						(t (simplify (list op ft st)))
					)
				)
				((equal op '+)
					(cond
						((== ft 0) st)
						((== st 0) ft)
						((and (numberp ft) (numberp st)) (+ ft st))
						((equal ft st) (simplify (list '* 2 ft)))
						(t (list '+ ft st))
					)
				)
				((equal op '-)
					(cond
						((and (== ft 0) (== st 0)) 0)
						((== ft 0) (simplify (list '* -1 st)))
						((== st 0) ft)
						((and (numberp ft) (numberp st)) (- ft st))
						(t (list '- ft st))
					)
				)
				((equal op '*)
					(cond
						((or (== ft 0) (== st 0)) 0)
						((== ft 1) st)
						((== st 1) ft)
						((and (numberp ft) (numberp st)) (* ft st))
						((equal ft st) (simplify (list '^ ft 2)))
						((and (listp st) (equal (car st) '/) (== (cadr st) 1)) (simplify (list '/ ft (caddr st))))
						((and (listp ft) (equal (car ft) '/) (== (cadr ft) 1)) (simplify (list '/ st (caddr ft))))
						(t (list '* ft st))
					)
				)
				((equal op '/)
					(cond
						((and (listp st) (equal (car st) '/)) (simplify (list '* ft (simplify (list '/ (caddr st) (cadr st))))))
						((== ft 0) 0)
						((== st 1) ft)
						((and (numberp ft) (numberp st)) (/ ft st))
						((equal ft st) 1)
						((numberp st) (simplify (list '* (/ st) ft)))
						(t (list '/ ft st))
					)
				)
				((equal op '^)
					(cond
						((== st 0) 1)
						((== st 1) ft)
						((and (listp ft) (equal (car ft) '^)) (simplify (list '^ (cadr ft) (list '* (caddr ft) st))))
						(t (list '^ ft st))
					)
				)
				((equal op 'sin)
					(if (numberp ft) (sin ft) (list 'sin ft))
				)
				((equal op 'cos)
					(if (numberp ft) (cos ft) (list 'cos ft))
				)
				((equal op 'ln)
					(cond
						((numberp ft) (log ft))
						((equal ft 'e) 1)
						(t (list 'ln ft))
					)
				)
				(t (error "~&Unknown operator: ~S" op))
			)
		)
	)
)

(defun print-poly (term)
	(if (atom term)
		term
		(if (== 3 (length term))
			(list (print-poly (cadr term)) (car term) (print-poly (caddr term)))
			(list (car term) (list (print-poly (cadr term))))
		)
	)
)

(defun read-poly (e)
	(let
		(
		 (result nil)
		)
		(labels
			(
			 (remsp (l) (cond ((null l) nil) ((equal (car l) #\space) (remsp (cdr l))) (t (cons (car l) (remsp (cdr l))))))
			 (remove-spaces (e) (remsp (coerce (string-upcase e) 'list)))
			 (read-number (lst) (setf (cons (read-from-string (reverse (do ((l lst (cdr l)) (r nil (cons (car l) r))) ((null l) r) () ))) result) result))

